/**
 *  sss - Space Shared Scheduler
 *  JobSpec - Simulator subsystem
 */



#ifndef __SSS_H
#include "sss.h"
#endif



#ifndef __JOBSPEC_H
#define __JOBSPEC_H



// SAVE_MEMORY avoids storing a job's name and owner
#define SAVE_MEMORY



#include <string.h>
#ifdef AIX
#	include <strings.h>
#endif

#include "job.h"
#include "list.h"
#include "clock.h"
#include "nasjobs.h"



#ifdef __JOBSPEC_CPP
	const char* str_modified = "modified";
	const char* str_original = "original";
#else
	extern const char* str_modified;
	extern const char* str_original;
#endif



typedef enum { jst_fixed, jst_downey, jst_nas } JobSpecType;
inline JobSpecType genjobspectype( char* name ){
	if( strcasecmp( name, "fixed" ) == 0 ){
		return jst_fixed;
	} 
	else 
	if( strcasecmp( name, "downey" ) == 0 ){
		return jst_downey;
	} 
	else 
	if( strcasecmp( name, "nas" ) == 0 ){
		return jst_nas;
	}
	else {
		fatal1( "unknown jobspec type: %s", name );
	}
	return (JobSpecType) 0;	// this gets rid of a warning
};
char* jobspectypename( JobSpecType type );



typedef enum { jss_completed, jss_cancelled, jss_not_used } JobSpecStatus;
inline JobSpecStatus genjobspecstatus( char* name ){
	if( strcasecmp( name, "completed" ) == 0 ){
		return jss_completed;
	} 
	else 
	if( strcasecmp( name, "exceeded" ) == 0 ){
		return jss_completed;
	} 
	else 
	if( strcasecmp( name, "removed" ) == 0 ){
		return jss_cancelled;
	} 
	else 
	if( strcasecmp( name, "cancelled" ) == 0 ){
		return jss_cancelled;
	}
	else {
		fatal1( "unknown jobspec status: %s", name );
	}
	return (JobSpecStatus) 0;	// this gets rid of a warning
};
char* jobspecstatusname( JobSpecStatus status );



class JobSpec {

	static int js_nextserialnumber;

public:

	// for all jobs
	int js_serialnumber;		  // an unique id generated by this class 
#	ifdef SAVE_MEMORY
		char js_name;
		char js_owner;
#	else
		Name js_name;
		Name js_owner;
#	endif
	Name js_tag;
	JobSpecType js_type;
	Time js_queued;
	bool js_submitted;
#	define MAX_SUPERCOMPUTERS 10
	int js_ssss;									// how many supercomputers this job has been submitted to
	SSS* js_sss[MAX_SUPERCOMPUTERS];				// which supercomputers this job should be submitted
#	define js_homesss js_sss[0]						// even if the job hasn't been submitted yet, there is
													// the concept of home supercomputing
	
	// for js_type == str_fixed
	int js_nodes;
	Time js_reqtime;
	Time js_start;
	Time js_finish;									// js_finish is used by itself when js_status == str_cancelled
	JobSpecStatus js_status;
	
	JobSpec( SSS* sss, char* name, char* owner, char* tag, Time queued, int nodes, Time reqtime, Time start, Time finish, JobSpecStatus status ){
		js_serialnumber = js_nextserialnumber++;
		js_ssss = 1;
		js_homesss = sss;
#		ifdef SAVE_MEMORY
			js_name = '*';
			js_owner = '*';
#		else
			strcpy( js_name, name );
			strcpy( js_owner, owner );
#		endif
		strcpy( js_tag, tag );
		js_queued = queued;
		js_type = jst_fixed;
		js_nodes = nodes;
		js_reqtime = reqtime;
		js_start = start;
		js_finish = finish;
		js_status = status;
		js_submitted = false;
	}

	// for js_type == str_downey
	Time js_canceled;
	Time js_L;
	double js_A;
	double js_sigma;
#	define JS_MAX_OPTIONS 25
	int js_options;
	int js_option[JS_MAX_OPTIONS];

	JobSpec( SSS* sss, char* name, char* owner, char* tag, Time queued, Time canceled, Time L, double A, double sigma, double accuracy, int options ){
		js_serialnumber = js_nextserialnumber++;
		if( js_serialnumber == 1001 ){
			js_serialnumber = js_serialnumber;
		}
		js_ssss = 1;
		js_homesss = sss;
#		ifdef SAVE_MEMORY
			js_name = '*';
			js_owner = '*';
#		else
			strcpy( js_name, name );
			strcpy( js_owner, owner );
#		endif
		strcpy( js_tag, tag );
		js_queued = queued;
		js_canceled = canceled;
		js_type = jst_downey;
		js_L = L;
		js_A = A;
		js_sigma = sigma;
		js_accuracy = accuracy;
		if( options > JS_MAX_OPTIONS ){
			fatal( "more options than JS_MAX_OPTIONS" );
		}
		js_options = options;
		js_status = jss_not_used;
		js_submitted = false;
	}

	// for js_type == str_nas
	NasBench js_bench;
	NasClass js_class;
	double js_accuracy;
	
	JobSpec( SSS* sss, char* name, char* owner, char* tag, Time queued, char* nasbench, char* nasclass, double accuracy ){
		js_serialnumber = js_nextserialnumber++;
		js_ssss = 1;
		js_homesss = sss;
#		ifdef SAVE_MEMORY
			js_name = '*';
			js_owner = '*';
#		else
			strcpy( js_name, name );
			strcpy( js_owner, owner );
#		endif
		strcpy( js_tag, tag );
		js_queued = queued;
		js_type = jst_nas;
		
		if( strcasecmp( nasbench, "LU" ) == 0 ){
			js_bench = nb_LU;
		}
		else if( strcasecmp( nasbench, "SP" ) == 0 ){
			js_bench = nb_SP;
		}
		else if( strcasecmp( nasbench, "BT" ) == 0 ){
			js_bench = nb_BT;
		}
		else if( strcasecmp( nasbench, "MG" ) == 0 ){
			js_bench = nb_MG;
		}
		else if( strcasecmp( nasbench, "EP" ) == 0 ){
			js_bench = nb_EP;
		}
		else {
			fatal1( "%s is not a valid NAS benchmark", nasbench );
		}

		if( strcasecmp( nasclass, "B" ) == 0 ){
			js_class = nc_B;
		}
		else if( strcasecmp( nasclass, "C" ) == 0 ){
			js_class = nc_C;
		}
		else {
			fatal1( "%s is not a valit NAS class", nasclass );
		}

		js_accuracy = accuracy;
		js_status = jss_not_used;

		js_submitted = false;
	}

	// submit the jobspec
	void submit( SSS* sss, int requests, Request* request, char* tag, CallBackFunc starthandler, CallBackFunc interrupthandler, void* handlerparam );

	// the execution time of a job on #nodes# nodes on supercomputer #sss#
	Time exectime( int nodes, SSS* sss );

	// the requests of a job
	int requests();
	Request* request( SSS* sss );

	// to support List<JobSpec>
	int id(){
		return js_serialnumber;
	}
	int rank(){
		return 0;
	}

	// to support addnas
	void setserialnumber( int serialnumber ){
		js_serialnumber = serialnumber;
	}

};



void readjobs( char* jobsfile, SSS* sss, List<JobSpec>* jobspeclist, bool richrequests = true );
void writestatic( List<JobSpec>* jobspeclist, char* workload_fn, char* extension = "static" );
void writetarget( List<JobSpec>* jobspeclist, char* workload_fn, char* extension = "target" );
void writedowneyoptions( List<JobSpec>* jobspeclist, int options, char* workload_fn, char* extension = "option_" );
void writenaive( List<JobSpec>* jobspeclist, char* workload_fn, char* extension = "naive" );
void writebushel( List<JobSpec>* jobspeclist, char* workload_fn, char* extension = "bushel" );
void writenasoptions( List<JobSpec>* jobspeclist, int max_options, NasJobs* nasjobs, int availnodes, char* workload_fn, char* extension = "option_" );



#endif

